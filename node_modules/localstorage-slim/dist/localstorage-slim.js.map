{"version":3,"file":"localstorage-slim.js","mappings":"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","sources":["webpack://ls/webpack/universalModuleDefinition","webpack://ls/webpack/bootstrap","webpack://ls/webpack/runtime/define property getters","webpack://ls/webpack/runtime/hasOwnProperty shorthand","webpack://ls/./src/helpers.ts","webpack://ls/./src/ls.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ls\"] = factory();\n\telse\n\t\troot[\"ls\"] = factory();\n})(this, () => {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","import type { Dictionary } from './types';\n\nexport const NOOP = (...args: unknown[]): unknown => undefined;\n\n// @deprecated @todo: remove in v3.\nexport const escapeRegExp = (text: string): string => text.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n\nexport const isObject = (item: any): boolean => {\n  return item !== null && item?.constructor.name === 'Object';\n};\n\n/** Specific to local-storage */\n\nexport const memoryStore = (): Storage => {\n  // @deprecated @todo: remove usage in v3. Export it and allow enduser to implement it themselves if need be\n  // because as of Feb 2023 ALL webbrowsers support LS (even in incognito mode)\n  // thrown error is generally due to a security policy (or perhaps exceeding storage capacity)\n  const mStore = {\n    getItem: (key: string) => store[key] || null,\n    setItem: (key: string, value: string) => {\n      store[key] = value;\n    },\n    removeItem: (key: string) => {\n      store[key] = undefined;\n    },\n    clear: () => {\n      store = {\n        __proto__: mStore,\n      };\n    },\n  };\n\n  let store: Dictionary = {\n    __proto__: mStore,\n  };\n\n  return store as Storage;\n};\n","/*\n * https://github.com/niketpathak/localstorage-slim\n * Copyright (c) 2021 Niket Pathak\n * MIT License\n */\n\nimport { isObject, NOOP, memoryStore } from './helpers';\nimport type { Encrypter, Decrypter, StorageConfig } from './types';\n\n// private fields\nlet isInit: boolean;\nlet storage: Storage;\n\nconst init = () => {\n  if (isInit) return;\n  isInit = true;\n  try {\n    // sometimes localStorage/sessionStorage is blocked due to security policy. For example, within JS fiddle in incognito mode\n    storage = config.storage || localStorage;\n    storage.getItem('');\n  } catch {\n    storage = memoryStore();\n  }\n\n  flush();\n};\n\n// Apex\nconst APX = String.fromCharCode(0);\n\n// tiny obsfuscator as a default implementation\nconst encrypter: Encrypter | Decrypter = (str, key, encrypt = true) =>\n  encrypt\n    ? [...(JSON.stringify(str) as unknown as string[])]\n      .map((x) => String.fromCharCode(x.charCodeAt(0) + (key as number)))\n      .join('')\n    : JSON.parse([...(str as string[])].map((x) => String.fromCharCode(x.charCodeAt(0) - (key as number))).join(''));\n\nconst decrypter: Decrypter = (str, key) => encrypter(str, key, false);\n\nconst config: StorageConfig = {\n  ttl: null,\n  encrypt: false,\n  encrypter,\n  decrypter,\n  secret: 75,\n  storage: undefined,\n};\n\nObject.seal(config);\n\nconst set = <T = unknown>(key: string, value: T, localConfig: Omit<StorageConfig, 'storage'> = {}): void | boolean => {\n  init();\n\n  const _conf = {\n    ...config,\n    ...localConfig,\n    encrypt: localConfig.encrypt === false ? false : localConfig.encrypt || config.encrypt,\n    ttl: localConfig.ttl === null ? null : localConfig.ttl || config.ttl,\n  };\n\n  try {\n    const hasTTL = _conf.ttl && !isNaN(_conf.ttl) && _conf.ttl > 0;\n    let val = hasTTL ? { [APX]: value, ttl: Date.now() + (_conf.ttl as number) * 1e3 } : value;\n\n    if (_conf.encrypt) {\n      // if ttl exists, only encrypt the value\n      if (hasTTL) {\n        (val as Record<string, unknown>)[APX] = (_conf.encrypter || NOOP)(\n          (val as Record<string, unknown>)[APX],\n          _conf.secret\n        ) as string;\n      } else {\n        val = (_conf.encrypter || NOOP)(val, _conf.secret) as T;\n      }\n    }\n\n    storage.setItem(key, JSON.stringify(val));\n  } catch {\n    // Sometimes stringify fails due to circular refs\n    return false;\n  }\n};\n\nconst get = <T = unknown>(key: string, localConfig: Omit<StorageConfig, 'storage'> = {}): T | null => {\n  init();\n\n  const str = storage.getItem(key);\n\n  const _conf = {\n    ...config,\n    ...localConfig,\n    encrypt: localConfig.encrypt === false ? false : localConfig.encrypt || config.encrypt,\n    ttl: localConfig.ttl === null ? null : localConfig.ttl || config.ttl,\n  };\n\n  let item;\n  let hasTTL;\n\n  try {\n    item = JSON.parse(str || '');\n    hasTTL = isObject(item) && APX in item;\n\n    if (_conf.decrypt || _conf.encrypt) {\n      if (hasTTL) {\n        item[APX] = (_conf.decrypter || NOOP)(item[APX], _conf.secret) as string;\n      } else {\n        item = (_conf.decrypter || NOOP)(item, _conf.secret) as string;\n      }\n    }\n  } catch {\n    // Either the secret is incorrect or there was a parsing error\n    // do nothing [i.e. return the encrypted/unparsed value]\n  }\n\n  // if not using ttl, return immediately\n  if (!hasTTL) {\n    return item !== undefined ? item : str;\n  }\n\n  if (Date.now() > item.ttl) {\n    storage.removeItem(key);\n    return null;\n  }\n\n  return item[APX];\n};\n\nconst flush = (force = false): void => {\n  init();\n  for (const key of Object.keys(storage)) {\n    const str = storage.getItem(key);\n    let item;\n    try {\n      item = JSON.parse(str || '');\n    } catch {\n      // Some packages write strings to localStorage that are not converted by JSON.stringify(), so we need to ignore it\n      continue;\n    }\n    // flush only if ttl was set and is expired or is forced to clear\n    if (isObject(item) && APX in item && (Date.now() > item.ttl || force)) {\n      storage.removeItem(key);\n    }\n  }\n};\n\nconst remove = (key: string): void => {\n  init();\n  storage.removeItem(key);\n};\n\nconst clear = (): void => {\n  init();\n  storage.clear();\n};\n\nexport default {\n  config,\n  set,\n  get,\n  flush,\n  clear,\n  remove,\n};\n"],"names":["root","factory","exports","module","define","amd","this","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","NOOP","args","isObject","item","constructor","name","isInit","storage","init","config","localStorage","getItem","mStore","store","setItem","value","removeItem","undefined","clear","__proto__","memoryStore","flush","APX","String","fromCharCode","encrypter","str","encrypt","JSON","stringify","map","x","charCodeAt","join","parse","ttl","decrypter","secret","seal","force","keys","Date","now","set","localConfig","_conf","hasTTL","isNaN","val","decrypt","remove"],"sourceRoot":""}